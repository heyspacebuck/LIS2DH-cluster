# Parsing the raw.csv generated by running lis2dh_cluster.py
g = 9.806

def twos_complement(lsb, msb):
  signBit = (msb & 0b10000000) >> 7
  msb &= 0x7F  # Strip off sign bit
  if signBit:
    x = (msb << 8) + lsb
    x ^= 0x7FFF
    x = -1 - x
  else:
    x = (msb << 8) + lsb
  x = x>>6  # Remove left justification of data
  return x


offset = 'not_set'
with open('raw.csv', 'r') as infile:
  with open('parsed.csv', 'a') as outfile:
    
    # Read the first line (the column headers)
    headers = infile.readline().strip('\n\r')
    headers = headers.split(';')
    newheaders = []
    for header in headers:
      if header == 't': newheaders += ['t']
      else: newheaders += [header+'x', header+'y', header+'z']
    newheaders = ','.join(newheaders)
    outfile.write(newheaders + '\n')
    
    # Read and parse all sequential lines
    line_in = infile.readline().strip('\n\r')
    while line_in:
      line_out = ''
      data = line_in.split(';')
      timestamp = eval(data[0])
      if offset == 'not_set':
        offset = timestamp
      line_out += str(timestamp - offset)
      for accel in data[1:]:
        array = eval(accel)  # Quick and dirty way of converting string to array
        line_out += ','
        line_out += str(twos_complement(array[0], array[1]))
        line_out += ','
        line_out += str(twos_complement(array[2], array[3]))
        line_out += ','
        line_out += str(twos_complement(array[4], array[5]))
      line_out += '\n'
      outfile.write(line_out)
      try:
        line_in = infile.readline().strip('\n\r')
      except:
        pass